## 8. AI Credits and Budget Enforcement

### 1) Purpose and Scope

1. **Purpose.** AI Credits exist to (a) cap LLM-related spend, (b) provide predictable unit-based consumption for tenants/users, and (c) ensure the platform does not exceed a defined **spend ceiling** relative to what the customer paid.
2. **Scope.** AI Credits apply to **all billable AI operations**, including but not limited to:

   * LLM generations (chat/completions, tool-augmented runs, retries).
   * Embeddings (query, document, re-embedding, batch indexing).
   * Reranking, classification, summarization, background extraction, “silent” calls.
   * Any provider-side costs incurred by the intelligence layer on behalf of a tenant/user.
3. **Non-scope.** Non-AI compute costs (standard DB queries, non-AI workers, static file serving) are not governed by AI Credits unless explicitly opted into a unified credit system.

### 2) Definitions

1. **Tenant**: A billing entity (organization/account) that owns users, data, and budgets.
2. **User**: An actor within a tenant (human or service principal) that can initiate requests.
3. **AI Operation**: Any action that triggers an external or internal model invocation (generation/embedding/rerank/etc.).
4. **Usage Event**: A single recorded AI operation with its measured usage (tokens, characters, images, seconds, etc.) and computed cost.
5. **Credit**: An integer unit representing billable AI consumption.
6. **Credit Balance**: Remaining credits available to a tenant or user.
7. **Spend Coefficient (α)**: A per-tenant or per-user parameter set at signup/billing that limits maximum LLM spend relative to amount paid.
8. **Credit Rate (R)**: Global conversion rate of USD to credits (credits per USD), versioned.
9. **Pricing Version**: A versioned snapshot of provider pricing rules used for cost calculation at a point in time.

### 3) Credit Plan Parameters

Each tenant (and optionally each user) MUST have an explicit credit plan with:

1. **Amount Paid (P_usd)**: The amount paid for the plan period or package.
2. **Spend Coefficient (α)**: A number in (0, 1] by default (or higher if you intentionally subsidize/upsell), defining:

   * **Spend Cap (S_usd) = P_usd × α**
3. **Credit Rate (R)**: Credits per USD (global default), e.g. `R = 100 credits/USD` (meaning 1 credit = $0.01 of AI cost).
4. **Credit Grant (G_credits)**:

   * **Default rule (recommended):** `G_credits = floor(S_usd × R)` at plan activation.
   * Optional: add promotional/bonus credits explicitly as separate grants.
5. **Expiry Policy**: Optional expiration date for unused credits (e.g., end of billing cycle).
6. **Overage Policy** (must be explicit):

   * **Hard-stop** (default): no billable AI operations when credits are exhausted.
   * **Overdraft** (optional): allow going negative up to a configured limit, then hard-stop.
7. **Allocation Policy**:

   * Tenant-pool only, or
   * Tenant-pool + per-user sub-budgets, with deterministic precedence.

### 4) Costing and Conversion Rules

1. **Source of truth for usage.** For each AI Operation, the system MUST record the provider-reported usage metrics (e.g., input tokens, output tokens, cached tokens, embedding tokens). If a provider does not return usage, the system MUST estimate conservatively and mark the event as “estimated”.
2. **Cost calculation.** Each Usage Event MUST compute:

   * `cost_usd = Σ(usage_component × provider_unit_price)` using a **Pricing Version**.
   * If you apply internal margin/overhead, it MUST be explicit and versioned (e.g., `effective_cost_usd = cost_usd × (1 + overhead_pct)`).
3. **Credits deducted.** Credits MUST be computed deterministically from the (effective) USD cost:

   * **Rule:** `credits = ceil(effective_cost_usd × R)`
   * **Minimum charge:** optionally `min_credits_per_event = 1` (only if you want to avoid “free microcalls”).
4. **Rounding invariants.**

   * Rounding MUST be consistent across the platform.
   * The system MUST store both the exact USD cost (decimal) and the final integer credits to allow reconciliation.

### 5) When Credits Are Charged

1. **Per-request settlement.** Credits MUST be computed as the **sum of all Usage Events** generated by a single user prompt/request (including background calls triggered by it).
2. **Atomic debit.** At the end of the request, the system MUST:

   * compute `total_credits`,
   * perform an **atomic** decrement of the appropriate balance,
   * write an immutable ledger entry that includes the request_id.
3. **Idempotency.** Debiting MUST be idempotent:

   * The debit operation MUST include `request_id` (and optionally `idempotency_key`).
   * Replays/retries MUST NOT double-charge.
4. **Streaming/SSE constraint.** If the response is streamed (SSE), the system MUST still guarantee budget enforcement:

   * The request MUST acquire a **credit reservation** before initiating billable operations, OR
   * enforce incremental “checkpoint” debits during long streams (less preferred).

### 6) Credit Reservation and Settlement (Strongly Recommended)

To prevent overspend mid-request, the platform SHOULD use a two-phase model:

1. **Pre-Authorization (Reserve).**

   * Compute an estimated upper bound `reserve_credits` based on:

     * chosen model, max_tokens, expected tool calls, retry policy, embedding batch size, etc.
   * If available balance < reserve_credits, the request MUST:

     * either hard-fail with “insufficient credits”, OR
     * downgrade to a cheaper mode/model if allowed by policy.
2. **Execution.**

   * All billable AI Operations MUST check they are covered by the reservation.
3. **Settlement (Capture).**

   * At completion, compute `actual_credits`.
   * Finalize by converting the reservation into an actual debit:

     * debit actual_credits, release unused reserved credits.
4. **Safety valve.**

   * If actual usage threatens to exceed reserved credits, the system MUST either:

     * stop initiating new billable operations, or
     * request an additional reservation (if balance allows), or
     * downgrade behavior.

### 7) Enforcement Behavior

1. **Hard-stop rule (default).** When a tenant/user has insufficient credits for reservation or execution, the system MUST:

   * refuse to perform further billable AI Operations, and
   * return a clear, structured error indicating credit exhaustion.
2. **Degradation rules (optional).** If configured, the system MAY:

   * switch to cheaper models,
   * reduce max_tokens,
   * disable optional background steps (extra reranking, summarization, agent loops),
   * use cached results only.
3. **No silent overspend.** The system MUST NOT exceed the spend cap (as represented by credits) without an explicit overage policy.

### 8) Storage, Ledger, and Audit Requirements

1. The platform MUST store:

   * **Credit Balance** (current balance per tenant and optionally per user),
   * **Credit Ledger** (immutable append-only events),
   * **Usage Events** (one row per AI Operation with usage + cost breakdown),
   * **Pricing Versions** (versioned price tables used for computation).
2. Ledger entries MUST include at minimum:

   * tenant_id, user_id (if applicable),
   * request_id, timestamp,
   * delta_credits (negative for consumption, positive for grants/refunds),
   * balance_after,
   * pricing_version,
   * breakdown pointer (or embedded summary) linking to underlying Usage Events.
3. The system MUST support reconciliation:

   * Ability to recompute credits from stored usage + pricing_version.
   * Daily/weekly reconciliation jobs are RECOMMENDED to detect drift.

### 9) Transparency and Customer-Facing Controls

1. The platform SHOULD provide:

   * current balance,
   * usage summaries by day/model/feature,
   * last N ledger entries,
   * estimated cost per request (when feasible).
2. The platform MAY emit webhooks/events:

   * `credits.low`, `credits.exhausted`, `credits.granted`, `credits.adjusted`.
3. Threshold alerts SHOULD be configurable (e.g., 20%, 10%, 0%).

### 10) Administrative Controls and Dispute Handling

1. Only authorized billing/admin actors MAY:

   * grant credits,
   * refund credits,
   * adjust α, R, expiry, or overdraft limits.
2. All manual adjustments MUST create ledger entries with:

   * reason code,
   * operator identity,
   * audit timestamp.

### 11) Placement and Cross-References

1. This Article MUST be treated as **normative** for implementation.
2. This Article MUST be cross-referenced by:

   * Rate Limiting and Abuse Policy (credits act as an economic rate limiter),
   * Observability Policy (usage and cost must be observable),
   * Tenancy and Isolation Policy (budgets must not leak across tenants),
   * Job/Worker Policy (background jobs must still debit the initiating request or an explicit budget).
